% !TeX root = ..\discrete_math.tex
\chapter{Теория графов}
\section{Основные определения}
Пусть $M$ и $N$ - два конечных множества. Будем называть пару множеств $\langle M, N \rangle$ \textbf{ориентированным графом}.
При этом элементы множества $M$ называются \textbf{вершинами} графа, элементы множества $N$ - \textbf{дугами} графа. 
Граф, у которого направления соединения не определены, называется \textbf{неориентированным графом}. В них
соединения называются \textbf{ребром}, а вершина - \textbf{узлом}.

\begin{figure*}[!h]
    \centering
    \begin{minipage}[t]{4cm}
        \centering
        \includegraphics{graph_or.jpg}
        \caption{Ориентированный граф}
    \end{minipage}
    \hspace{3cm}
    \begin{minipage}[t]{4cm}
        \centering
        \includegraphics{graph_nor.jpg}
        \caption{Неориентированный граф}
    \end{minipage}
\end{figure*}

\textbf{Висячей вершиной} называется вершина, которая соединена только с одной соседней вершиной.

\textbf{Степенью вершины} называется количество ребер, соединенных с этой вершиной.
Если степень вершины равна 0, то такая вершина называется \textbf{изолированной}.
Степень вершины может быть \textbf{входящей} и \textbf{исходящей}. Входящая степень вершины $v$
это количество ребер вида $\langle i, v \rangle$, то есть количество ребер которые входят в $v$.
Исходящая степень вершины $v$ это количество ребер вида $\langle v, i \rangle$, то есть количество ребер
которые входят из $v$.

\begin{thm}
    В любом графе всегда найдутся хотя бы две вершины с одинаковой степенью.
\end{thm}

Дуга, у которой начало и конец совпадают, называется \textbf{петлей}.

Граф $\langle M', N'\rangle$ называется \textbf{простым путем}, если
\begin{enumerate}
    \item число его дуг $k$ на единицу меньше числа вершин
    \item можно так пронумеровать $M'$ числами от 0 до $k$ и $N'$ числами от 1 до $k$,
    что для любой дуги $u \in N'$
\end{enumerate}

Пусть $num$ - это получение номера дуги или вершины, а $beg(u)$ и $end(u)$ начало и конец дуги 
$u$ соответственно. Тогда для любой дуги $u$ в графе верно выражение:
\begin{equation}
    \label{simple_path}
    num(u) = num(end(u)) = num(beg(u)) + 1
\end{equation}
Различие между \textbf{путем} и \textbf{простым путем} заключается в том, что во втором случае
недопустимы повторы вершин и дуг в пути.
\begin{figure}[h]
    \centering 
    \includegraphics{simple_path.jpg}
    \caption{Простой путь}
\end{figure}

Граф $\langle M', N'\rangle$ называется \textbf{цепью}, если:
\begin{enumerate}
    \item число его дуг $k$ на единицу меньше числа вершин
    \item можно так пронумеровать $M'$ числами от 0 до $k$ и $N'$ числами от 1 до $k$,
    что для любой дуги $u \in N'$
\end{enumerate}
То есть, он включает либо условие простого пути \ref{simple_path}, либо
\begin{equation}
    \label{chain}
    num(u) = num(end(u)) + 1 = num(beg(u))
\end{equation}
Дуги, для которых выполняется \ref{simple_path}, принято называть \textbf{положительно ориентированными},
а те, для которых выполняется \ref{chain} \textbf{отрицательно ориентированными}.

\begin{figure}[h]
    \centering 
    \includegraphics{chain.jpg}
    \caption{Цепь}
\end{figure}

Граф $\langle M', N'\rangle$ называется \textbf{контуром}, если
\begin{enumerate}
    \item число дуг $k$ равно числу вершин
    \item можно так пронумеровать $M'$ и $N'$ числами от 1 до k, что для любой
    дуги $u \in N'$
\end{enumerate}
\begin{equation}
    num(u) \stackrel{\text{mod k}}{=} num(end(u)) \stackrel{\text{mod k}}{=} num(beg(u)) + 1
\end{equation}
Иными словами, контур - это простой путь, где начало и конец совпадают.

\begin{figure}[h]
    \centering 
    \includegraphics{loop.jpg}
    \caption{Контур}
\end{figure}

\vspace{3mm}

Граф $\langle M', N'\rangle$ называется \textbf{циклом}, если
\begin{enumerate}
    \item число дуг $k$ равно числу вершин
    \item можно так пронумеровать $M'$ и $N'$ числами от 1 до $k$, что для любой дуги $u \in N'$
\end{enumerate}
\begin{equation}
    num(u) \stackrel{\text{mod k}}{=} num(end(u)) \stackrel{\text{mod k}}{=} num(beg(u)) + 1
\end{equation}
либо
\begin{equation}
    num(u) \stackrel{\text{mod k}}{=} num(end(u)) + 1 \stackrel{\text{mod k}}{=} num(beg(u))
\end{equation}
Цикл - это цепь, в которой начало и конец совпадают.
\begin{figure}[h]
    \centering 
    \includegraphics{cycle.jpg}
    \caption{Цикл}
\end{figure}

\section{Связность. Компоненты связности и сильной связности}
Граф $\langle M, N\rangle$ называется \textbf{связным}, если любые две различные его
вершины можно соединить цепью. Любой граф может быть однозначно разделен на максимальные
связные подграфы, которые называют его \textbf{компонентами связаности}.
c

Граф $\langle M, N\rangle$ называется \textbf{сильно связным}, если любые две различные
вершины A и B можно соединить путем с началом в A и концом в B. В любом графе можно однозначно
выделить максимальные сильно связные подграфы, которые называются его \textbf{компонентами сильной связности}.
\begin{thm}
    Граф компонент сильной связности не имеет контуров.
\end{thm}

\section{Матричные представления графов}
Прежде чем приступить к понятию "дерево" , изучим различные способы представления графов.
Наиболее известные формы это \textbf{матрица инциденций} и \textbf{матрица смежности}.
Для начала рассмотрим более простой вариант - матрицу смежности.

\vspace{3mm}

\textbf{Матрицей смежности} графа $\langle M, N\rangle$ называется такая квадратная матрица $M \times M$
(то есть индексами строк и столбцов являются вершины графа), 
в которой значением пересечения $i$-ой строки и $j$-го столбца является число дуг с началом в $i$ и концом $j$.

\begin{figure}[!h]
    \centering 
    \includegraphics{graph_1.jpg}
    \caption{Граф}
    \label{graph_for_matrix}
\end{figure}

\begin{figure*}[!h]
    \centering
    \begin{minipage}[t]{4cm}
        \centering
        \begin{tabular}[c]{ | l | l | l | l | l | l | l | l |}
            \hline
              & 1  & 2  & 3  & 4  & 5  & 6  \\ \hline
            A & 1  & 1  & 1  & 0  & 0  & 0  \\ \hline
            B & -1 & 0  & 0  & 0  & 1  & -1 \\ \hline
            C & 0  & -1 & 0  & 1  & 0  & 0  \\ \hline
            D & 0  & 0  & -1 & -1 & -1 & 1  \\
            \hline
        \end{tabular}
    \end{minipage}
    \hspace{3cm}
    \begin{minipage}[t]{4cm}\
        \centering
        \begin{tabular}[c]{ | l | l | l | l | l |}
            \hline
              & A & B & C & D \\ \hline
            A & 0 & 1 & 1 & 1 \\ \hline
            B & 0 & 0 & 0 & 1 \\ \hline
            C & 0 & 0 & 0 & 1 \\ \hline
            D & 0 & 1 & 0 & 0 \\
            \hline
        \end{tabular}
    \end{minipage}
    \caption{Способы матричного представления графа \ref{graph_for_matrix}: матрица инциденций
    и матрица смежности соответственно}
\end{figure*}

\hspace{3mm}

\textbf{Матрицей инциденции} графа $\langle M, N\rangle$ называется такая матрица $M \times N$, 
где индексами строк являются вершины, а индексами столбцов дуги. Элемент на пересечении $i$-ой строки и $j$-ого
столбца равен 1, если является началом в вершине под $i$-ым индексом и принадлежит дуге под $j$-ым индексом. Если же данная
дуга имеет конец в этой вершине, то ставится -1.

\section{Деревья}
Чтобы ввести термин "дерево", нам нужно изучить следующую теорму:
\begin{thm}
    В связном графе $\langle M, N \rangle$ найдется частичный граф связный граф
    $\langle M, N' \rangle$, в котором количество вершин больше количества дуг на единицу. Пусть $|N'| = k$, 
    тогда если пронумеровать вершины из M числами от 0 до k, а дуги из N' числами от 1 до k
    таким образом, что для любой дуги $u \in N'$ выполняется соотношение
    \begin{equation}
        num(u) = max\{num(beg(u)), num(end(u))\}
    \end{equation}
\end{thm}
\begin{sle}
    Если $|N| < |M| - 1$, граф не может быть связан.
\end{sle}
\begin{sle}
    Если $|N| > |M| - 1$, граф содержит циклы.
\end{sle}

Связный граф, в котором число дуг на 1 меньше числа вершин, называется
\textbf{деревом}. Такие деревья могут не иметь корня, в отличие от тех деревьев,
которые мы обычно представляем. Если подобное дерево имеет корень, то оно называется 
\textbf{ориентированным деревом}.
Дерево, являющееся частичным графом связного графа, называется его \textbf{остовным деревом} (spanning tree).

Теперь можно присутпить к изучению алгоритма нахождения остовного дерева методом вычеркивания.

\hspace{5mm}

\section{Алгоритмы нахождения остовного дерева}
\textbf{Алгоритм ближайшего соседа}
\begin{enumerate}
    \item В весовой матрице выбираем произвольную вершину.
    \item Ищем в этой весовой вершине минимальную дугу в другую вершину.
    \item Ищем среди этих вершин снова минимальную дугу уже в новую вершину.
    \item Продолжаем до тех пор, пока не пометим все вершины.
\end{enumerate}
Приведем пример. Пусть есть следующая весовая матрица:

\begin{table}[h]
    \centering
    \begin{tabular}[c]{ | l | l | l | l | l | l | l | }
        \hline
          & A & B & C & D & E & F \\ \hline
        A & 0 & 0 & $\infty$ & 4 & 6 & $\infty$ \\ \hline
        B & 5 & 0 & $\infty$ & 7 & 5 & 4\\ \hline
        C & $\infty$ & $\infty$ & 0 & 5 & 6 & 4 \\ \hline
        D & 4 & 7 & 5 & 0 & 8 & 3\\ \hline
        E & 6 & 5 & 6 & 8 & 0 & $\infty$\\ \hline
        E & $\infty$ & 4 & 4 & 3 & $\infty$ & 0 \\
        \hline
    \end{tabular}
    \caption{Весовая матрица}
\end{table}

\begin{figure}[!h]
    \centering 
    \includegraphics{kn.jpg}
    \caption{Алгоритм ближайшего соседа}
    \label{graph_kn}
\end{figure}

На рисунке \ref{graph_kn} изображен алгоритм построения остовного дерева для весовой матрицы выше. 
Пусть произвольная вершина будет A. Минимальное ребро идет в вершину D. 
Далее выбираем среди этих двух вершин минимальное ребро, и это D -> F. По такому же
алгоритму достраиваем остовное дерево.

\hspace{5mm}

\textbf{Жадный алгоритм}

Этот алгоритм основан по большей части на том, что каждый раз мы выбираем минимальное ребро
на каждом этапе, а далее объединяем полученные ребра в остовное дерево. Для той же весовой матрицы покажем:
На рисунке \ref{greedy_alg} изображено построение остовного дерева с помощью жадного алгоритма.

\begin{figure}[!h]
    \centering 
    \includegraphics{greedy_alg.jpg}
    \caption{Жадный алгоритм}
    \label{greedy_alg}
\end{figure}

Самое минимальное ребро равно 3 с вершинами D и F. Далее мы имеем 3 равнозначеных ребра равных 4:
F и B, F и C, D и A. Строми последовательно их. Не хватает последнего ребра E. Можно заметить, что самое минимальное
ребро с этой вершиной из B. Остовное дерево построено.

\hspace{5mm}

\textbf{Алгоритм вычеркивания}
\begin{enumerate}
    \item В матрице инцидентности $N \times N-1$ проверяем наличие нулевых строк. 
    Если есть, то имеем неостовное дерево.
    \item Если нет, то проверяем наличие строк с одной единицей
    и вычеркиваем строку и столбец, проходящие через эту единицу
    \item Повторяем пункт 1 и 2 до тех пор, пока не придем к выводу, что это неостовное дерево или
    если все столбцы вычеркнуты, то рассмотренные ребра образуют остовное дерево
\end{enumerate}

Рассмотрим пример. Имеем следующую матрицу инцидентности:
\begin{table}[h]
    \centering
    \begin{tabular}[c]{ | l | l | l | l | l | l | l | l | l | l | }
        \hline
        1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\ \hline
        1 & 0 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 \\ \hline
        0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 \\ \hline
        1 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
        0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 0 & 0 \\ \hline
        0 & 0 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 0 \\ \hline
        0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 \\ 
        \hline
    \end{tabular}
    \caption{Матрица инциденций}
\end{table}

Теперь проверим, являются ли ребра 1, 2, 5, 7 и 8 остовным деревом:
\begin{figure}[!h]
    \centering 
    \includegraphics{matrix1.jpg}
    \caption{Алгоритм вычеркивания}
\end{figure}

Так как в процессе у нас не возникло нулевых строк и в итоге все строки и столбцы 
были зачеркнуты, данные ребра образуют остовное дерево.
Например, ребра 1, 2, 4, 5 и 8 не будут образовывать остовное дерево, так как 5
строчка будет состоять только из нулей.

\section{Задача о кратчайшем пути}
Для того чтобы найти кратчайший путь от одной вершины до других, используется алгоритм Дейкстры.
Алгоритм работает только для графов без рёбер отрицательного веса.

Алгоритм заключается в том, что каждой вершине соотвествует минимальное известное расстояние от
этой вершины до \textbf{a}. Метка вершины \textbf{a}, от которой ищутся кратчайшие расстояния до других, изначально равна 0, метки
остальных вершин равны бесконечности. Алгоритм работает пошагово - на каждом шаге он посещает одну вершину
и пытается уменьшать метки: из еще непосещенных вершин выбирается та, которая имеет
минимальную метку. Для каждого непосещенного соседа вершины, рассмотрим новую длину пути,
равную сумме значений текущей метки и длины ребра, соединяющего ее с этим соседом.
Если все вершины посещены, то работа алгоритма прекращается.

Рассмотрим теперь пример:

Пусть требуется найти кратчайшие расстояния от 1-й вершины до всех остальных. 

\begin{figure}[!h]
    \centering 
    \includegraphics{dijkstra_1.png}
\end{figure}
